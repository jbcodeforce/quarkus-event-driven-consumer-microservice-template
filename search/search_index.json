{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Quarkus Microservice This project uses Quarkus and Kakfa consumer API to deliver a basic structured event driven microservice as a project template. What this project includes: Quarkus project template using: REST easy , SmallRYE open tracing, open API, fault tolerance health, metrics and Kafka client. Using graalVM to run the application. Kafka consumer API examples Nice documentation to present features, design and knowledge sharing using mkdocs See the BOOK view of the documentation. Principles Running the application in dev mode Detail in this note. Tests Detail in this note. Deployment on Openshift CI/CD details","title":"Introduction"},{"location":"#quarkus-microservice","text":"This project uses Quarkus and Kakfa consumer API to deliver a basic structured event driven microservice as a project template. What this project includes: Quarkus project template using: REST easy , SmallRYE open tracing, open API, fault tolerance health, metrics and Kafka client. Using graalVM to run the application. Kafka consumer API examples Nice documentation to present features, design and knowledge sharing using mkdocs See the BOOK view of the documentation.","title":"Quarkus Microservice"},{"location":"#principles","text":"","title":"Principles"},{"location":"#running-the-application-in-dev-mode","text":"Detail in this note.","title":"Running the application in dev mode"},{"location":"#tests","text":"Detail in this note.","title":"Tests"},{"location":"#deployment-on-openshift","text":"CI/CD details","title":"Deployment on Openshift"},{"location":"build-run/","text":"Build and run locally you can build a Quarkus application either as a standard Java application (using the docker build file: src/main/docker/Dockerfile.jvm )or as a native executable using GraalVM (and -Dnative) and the ( src/main/docker/Dockerfile.native ). Environment variables used KAFKA_BROKERS KAFKA_APIKEY If the topic name is different that the one in the application.properties KAFKA_MAIN_TOPIC When connected to a Kafka cluster using TLS certificate add: TRUSTSTORE_ENABLED TRUSTSTORE_PATH TRUSTSTORE_PWD Running the application in dev mode You can run your application in dev mode that enables live coding using: ./mvnw quarkus:dev When launching a Quarkus app simply using mvn quarkus:dev, the running application is configured to open port 5005 for remote debugging. That means that all you have to do is point your remote debugger to that port and you will be able to debug it in your favorite IDE/lightweight editor. Verify the memory usage: ps -o pid,rss,command -p $(grep -f runner) Packaging and running the application The application is packageable using ./mvnw package . It produces the executable quarkus-kafka-consumer-1.0.0-SNAPSHOT-runner.jar file in /target directory. Be aware that it\u2019s not an \u00fcber-jar as the dependencies are copied into the target/lib directory. The application is now runnable using java -jar target/quarkus-kafka-consumer-1.0.0-SNAPSHOT-runner.jar . Creating and run a native executable Start the GraalVM docker image to work in a contained development environment: docker run -ti -v $( pwd ) :/home -p 8080 :8080 oracle/graalvm-ce:latest You can create a native (to your local OS) executable using: ./mvnw package -Pnative . Or you can use Docker to build the linux native executable using: ./mvnw package -Pnative -Dquarkus.native.container-build = true You can then execute your binary: ./target/quarkus-kafka-consumer-1.0.0-SNAPSHOT-runner Deployment to openshift while developing Define the configuration map Create project oc new-project eda-sandbox --display-name = \"EDA kafka play with quarkus\" Build from native image Define a build configuration oc new-build quay.io/redhat/ubi-quarkus-native-runner --binary --name = eda-orders-consumer-native -l app = eda-orders-consumer oc start-build eda-orders-consumer-native --from-file = target/quarkus-kafka-consumer-1.0.0-SNAPSHOT-runner --follow !!! Note: The native image does not work as some of the SaslClient classes from Kafka API does not have a public no-argument constructor Build from source Define a pure java build process oc new-build registry.access.redhat.com/redhat-openjdk-18/openjdk18-openshift --binary --name=eda-orders-consumer -l app=eda-orders-consumer ./mvnw clean oc start-build eda-orders-consumer --from-file=. --follow Config the app and routes # the name of the application needs to match the app tag specified with the new build. oc new-app eda-orders-consumer # get the deployment configuration oc get dc # Add environment variables: c set env dc/eda-orders-consumer KAFKA_BROKERS = broker-3-qnprtqnp7hnkssdz.kafka.svc01.us-east.eventstreams.cloud.ibm.com:9093,broker-1-qnprtqnp7hnkssdz.kafka.svc01.us-east.eventstreams.cloud.ibm.com:9093,broker-0-qnprtqnp7hnkssdz.kafka.svc01.us-east.eventstreams.cloud.ibm.com:9093,broker-5-qnprtqnp7hnkssdz.kafka.svc01.us-east.eventstreams.cloud.ibm.com:9093,broker-2-qnprtqnp7hnkssdz.kafka.svc01.us-east.eventstreams.cloud.ibm.com:9093,broker-4-qnprtqnp7hnkssdz.kafka.svc01.us-east.eventstreams.cloud.ibm.com:9093 # Add secret for the api key and reference it for environment variables # expose the service as route to be accessible to external apps oc expose service eda-orders-consumer # get apps URL oc get routes # verify the access curl eda-orders-consumer-jb-sandbox.gse-eda-demos-...-0001.us-east.containers.appdomain.cloud/hello Next pure java build oc start-build eda-orders-consumer --from-file = . --follow","title":"Build & Run"},{"location":"build-run/#build-and-run-locally","text":"you can build a Quarkus application either as a standard Java application (using the docker build file: src/main/docker/Dockerfile.jvm )or as a native executable using GraalVM (and -Dnative) and the ( src/main/docker/Dockerfile.native ).","title":"Build and run locally"},{"location":"build-run/#environment-variables-used","text":"KAFKA_BROKERS KAFKA_APIKEY If the topic name is different that the one in the application.properties KAFKA_MAIN_TOPIC When connected to a Kafka cluster using TLS certificate add: TRUSTSTORE_ENABLED TRUSTSTORE_PATH TRUSTSTORE_PWD","title":"Environment variables used"},{"location":"build-run/#running-the-application-in-dev-mode","text":"You can run your application in dev mode that enables live coding using: ./mvnw quarkus:dev When launching a Quarkus app simply using mvn quarkus:dev, the running application is configured to open port 5005 for remote debugging. That means that all you have to do is point your remote debugger to that port and you will be able to debug it in your favorite IDE/lightweight editor. Verify the memory usage: ps -o pid,rss,command -p $(grep -f runner)","title":"Running the application in dev mode"},{"location":"build-run/#packaging-and-running-the-application","text":"The application is packageable using ./mvnw package . It produces the executable quarkus-kafka-consumer-1.0.0-SNAPSHOT-runner.jar file in /target directory. Be aware that it\u2019s not an \u00fcber-jar as the dependencies are copied into the target/lib directory. The application is now runnable using java -jar target/quarkus-kafka-consumer-1.0.0-SNAPSHOT-runner.jar .","title":"Packaging and running the application"},{"location":"build-run/#creating-and-run-a-native-executable","text":"Start the GraalVM docker image to work in a contained development environment: docker run -ti -v $( pwd ) :/home -p 8080 :8080 oracle/graalvm-ce:latest You can create a native (to your local OS) executable using: ./mvnw package -Pnative . Or you can use Docker to build the linux native executable using: ./mvnw package -Pnative -Dquarkus.native.container-build = true You can then execute your binary: ./target/quarkus-kafka-consumer-1.0.0-SNAPSHOT-runner","title":"Creating and run a native executable"},{"location":"build-run/#deployment-to-openshift-while-developing","text":"","title":"Deployment to openshift while developing"},{"location":"build-run/#define-the-configuration-map","text":"","title":"Define the configuration map"},{"location":"build-run/#create-project","text":"oc new-project eda-sandbox --display-name = \"EDA kafka play with quarkus\"","title":"Create project"},{"location":"build-run/#build-from-native-image","text":"Define a build configuration oc new-build quay.io/redhat/ubi-quarkus-native-runner --binary --name = eda-orders-consumer-native -l app = eda-orders-consumer oc start-build eda-orders-consumer-native --from-file = target/quarkus-kafka-consumer-1.0.0-SNAPSHOT-runner --follow !!! Note: The native image does not work as some of the SaslClient classes from Kafka API does not have a public no-argument constructor","title":"Build from native image"},{"location":"build-run/#build-from-source","text":"Define a pure java build process oc new-build registry.access.redhat.com/redhat-openjdk-18/openjdk18-openshift --binary --name=eda-orders-consumer -l app=eda-orders-consumer ./mvnw clean oc start-build eda-orders-consumer --from-file=. --follow","title":"Build from source"},{"location":"build-run/#config-the-app-and-routes","text":"# the name of the application needs to match the app tag specified with the new build. oc new-app eda-orders-consumer # get the deployment configuration oc get dc # Add environment variables: c set env dc/eda-orders-consumer KAFKA_BROKERS = broker-3-qnprtqnp7hnkssdz.kafka.svc01.us-east.eventstreams.cloud.ibm.com:9093,broker-1-qnprtqnp7hnkssdz.kafka.svc01.us-east.eventstreams.cloud.ibm.com:9093,broker-0-qnprtqnp7hnkssdz.kafka.svc01.us-east.eventstreams.cloud.ibm.com:9093,broker-5-qnprtqnp7hnkssdz.kafka.svc01.us-east.eventstreams.cloud.ibm.com:9093,broker-2-qnprtqnp7hnkssdz.kafka.svc01.us-east.eventstreams.cloud.ibm.com:9093,broker-4-qnprtqnp7hnkssdz.kafka.svc01.us-east.eventstreams.cloud.ibm.com:9093 # Add secret for the api key and reference it for environment variables # expose the service as route to be accessible to external apps oc expose service eda-orders-consumer # get apps URL oc get routes # verify the access curl eda-orders-consumer-jb-sandbox.gse-eda-demos-...-0001.us-east.containers.appdomain.cloud/hello","title":"Config the app and routes"},{"location":"build-run/#next-pure-java-build","text":"oc start-build eda-orders-consumer --from-file = . --follow","title":"Next pure java build"},{"location":"compendium/","text":"Application Compendium Getting Started with openshift on learn.openshift.com EDA IBM Event Driven Reference architecture Event driven design patterns Kafka producer implementation considerations Kafka consumer implementation considerations Kafka Streams introduction Cloud Native with Quarkus Quarkus Getting started building native executables REST easy SmallRYE SmallRye develops implementations of Eclipse MicroProfile APIs within any runtime, but here it is for quarkus, and offers a set of components to develop cloud native Java apps. Getting started with Graal VM : GraalVM is a standalone Java Development Kit to execute Java or JVM-based languages (e.g., Scala, Kotlin), dynamic languages (e.g., JavaScript, R, Ruby, R, Python), LLVM-based languages (e.g., C and C++). Java microprofile GraalVM Top 10 Things To Do With GraalVM GraalVM Examples](https://www.graalvm.org/docs/examples/)","title":"Compendium"},{"location":"compendium/#application-compendium","text":"Getting Started with openshift on learn.openshift.com","title":"Application Compendium"},{"location":"compendium/#eda","text":"IBM Event Driven Reference architecture Event driven design patterns Kafka producer implementation considerations Kafka consumer implementation considerations Kafka Streams introduction","title":"EDA"},{"location":"compendium/#cloud-native-with-quarkus","text":"Quarkus Getting started building native executables REST easy SmallRYE SmallRye develops implementations of Eclipse MicroProfile APIs within any runtime, but here it is for quarkus, and offers a set of components to develop cloud native Java apps. Getting started with Graal VM : GraalVM is a standalone Java Development Kit to execute Java or JVM-based languages (e.g., Scala, Kotlin), dynamic languages (e.g., JavaScript, R, Ruby, R, Python), LLVM-based languages (e.g., C and C++). Java microprofile","title":"Cloud Native with Quarkus"},{"location":"compendium/#graalvm","text":"Top 10 Things To Do With GraalVM GraalVM Examples](https://www.graalvm.org/docs/examples/)","title":"GraalVM"},{"location":"devops/","text":"DevOps Continuous integration Continuous deployment App Monitoring","title":"DevOps"},{"location":"devops/#devops","text":"","title":"DevOps"},{"location":"devops/#continuous-integration","text":"","title":"Continuous integration"},{"location":"devops/#continuous-deployment","text":"","title":"Continuous deployment"},{"location":"devops/#app-monitoring","text":"","title":"App Monitoring"},{"location":"quarkus-summary/","text":"Quarkus Summary Quarkus is a Kubernetes Native Java stack tailored for OpenJDK HotSpot and GraalVM. Create a template Using this web site , select the package and download. Run development mode quarkus:dev runs Quarkus in development mode. This enables hot deployment with background compilation, which means that when you modify your Java files and/or your resource files and refresh your browser, these changes will automatically take effect. Using GraalVM You can use a multi-stage Docker build to run Maven inside a Docker container that embeds GraalVM. Start a container and verify java -version or node . docker run -it -v $( pwd ) :/home -p 8080 :8080 oracle/graalvm-ce:20.0.0 bash See other usages here For python, in the bash session in the graalvm container: gu install python graalpython GraalVM can compile Java bytecode into native images to achieve faster startup and smaller footprint for your applications. javac HelloWorld.java native-image HelloWorld ./HelloWorld When using maven in the container, the internal maven repository will be update when doing mvn package . We can do a docker commit <containerid> jbcodeforce/newgraalvm to keep those installation between container sessions, and use this image for future runs. One of the limitations of GraalVM is the usage of Reflection. Reflective operations are supported but all relevant members must be registered for reflection explicitly. Microprofile app with quarkus Start by creating a microprofile base code with Microprofile starter . Replace the \"starter\" maven pom.xml file with a new one, created for Quarkus with the following command (verify quarkus maven plugin version in mvn repository ): mvn io.quarkus:quarkus-maven-plugin:1.2.1.Final:create -DprojectGroupId = ibm.gse.eda -DprojectArtifactId = demo -Dextensions = \"smallrye-health, smallrye-metrics, smallrye-openapi, smallrye-fault-tolerance, smallrye-jwt, resteasy, resteasy-jsonb, arc\" Application initialization As part of the consumer implementation, is the need to start the consumer as soon as the application is started. Quarkus support two events: StartupEvent, ShutdownEvent that can be processed: void onStart ( @Observes StartupEvent ev ) { LOGGER . info ( \"The application is starting...\" ); } void onStop ( @Observes ShutdownEvent ev ) { LOGGER . info ( \"The application is stopping...\" ); } CDI CDI is supported by ArC and is part of the quarkus-resteasy extension. Variable injection is done with @Inject and @ConfigProperties . The order is properties < System.getEnv() < System.getProperties() @Inject @ConfigProperty ( name = \"main.topic.name\" ) protected String mainTopicName ; Bean classes that don\u2019t have a bean defining annotation are not discovered. This behavior is defined by CDI. But producer methods and fields and observer methods are discovered even if the declaring class is not annotated with a bean defining annotation By default, CDI beans are created lazily, when needed. A normal scoped bean (@ApplicationScoped, @RequestScoped, etc.) is needed when a method is invoked upon an injected instance (contextual reference per the specification). A bean with a pseudo-scope (@Dependent and @Singleton ) is created when injected In CDI event Singleton injection may not work as expected due to the propagation of the application context. For example in the case where we need to run the kafka consumer in an executor, we need to pass the configuration to the runner so it get the value injected in the properties, as those value are created in the application context, and will be null in the thread context. The configuration is injected into the runner in the application Bean @ApplicationScoped public class ApplicationBean { @Inject public KafkaConfiguration kafkaConfiguration ; public void onStart ( @Observes StartupEvent ev ) { executorService = Executors . newFixedThreadPool ( 1 ); mainEventRunner = new MainEventsRunner ( kafkaConfiguration ); @ApplicationScoped public class MainEventsRunner implements Runnable {} public KafkaConfiguration kafkaConfiguration ; public MainEventsRunner ( KafkaConfiguration kafkaConfiguration ) { this . kafkaConfiguration = kafkaConfiguration ; } Quick list of common commands See also this Cheat sheer","title":"Quarkus summary"},{"location":"quarkus-summary/#quarkus-summary","text":"Quarkus is a Kubernetes Native Java stack tailored for OpenJDK HotSpot and GraalVM.","title":"Quarkus Summary"},{"location":"quarkus-summary/#create-a-template","text":"Using this web site , select the package and download.","title":"Create a template"},{"location":"quarkus-summary/#run-development-mode","text":"quarkus:dev runs Quarkus in development mode. This enables hot deployment with background compilation, which means that when you modify your Java files and/or your resource files and refresh your browser, these changes will automatically take effect.","title":"Run development mode"},{"location":"quarkus-summary/#using-graalvm","text":"You can use a multi-stage Docker build to run Maven inside a Docker container that embeds GraalVM. Start a container and verify java -version or node . docker run -it -v $( pwd ) :/home -p 8080 :8080 oracle/graalvm-ce:20.0.0 bash See other usages here For python, in the bash session in the graalvm container: gu install python graalpython GraalVM can compile Java bytecode into native images to achieve faster startup and smaller footprint for your applications. javac HelloWorld.java native-image HelloWorld ./HelloWorld When using maven in the container, the internal maven repository will be update when doing mvn package . We can do a docker commit <containerid> jbcodeforce/newgraalvm to keep those installation between container sessions, and use this image for future runs. One of the limitations of GraalVM is the usage of Reflection. Reflective operations are supported but all relevant members must be registered for reflection explicitly.","title":"Using GraalVM"},{"location":"quarkus-summary/#microprofile-app-with-quarkus","text":"Start by creating a microprofile base code with Microprofile starter . Replace the \"starter\" maven pom.xml file with a new one, created for Quarkus with the following command (verify quarkus maven plugin version in mvn repository ): mvn io.quarkus:quarkus-maven-plugin:1.2.1.Final:create -DprojectGroupId = ibm.gse.eda -DprojectArtifactId = demo -Dextensions = \"smallrye-health, smallrye-metrics, smallrye-openapi, smallrye-fault-tolerance, smallrye-jwt, resteasy, resteasy-jsonb, arc\"","title":"Microprofile app with quarkus"},{"location":"quarkus-summary/#application-initialization","text":"As part of the consumer implementation, is the need to start the consumer as soon as the application is started. Quarkus support two events: StartupEvent, ShutdownEvent that can be processed: void onStart ( @Observes StartupEvent ev ) { LOGGER . info ( \"The application is starting...\" ); } void onStop ( @Observes ShutdownEvent ev ) { LOGGER . info ( \"The application is stopping...\" ); }","title":"Application initialization"},{"location":"quarkus-summary/#cdi","text":"CDI is supported by ArC and is part of the quarkus-resteasy extension. Variable injection is done with @Inject and @ConfigProperties . The order is properties < System.getEnv() < System.getProperties() @Inject @ConfigProperty ( name = \"main.topic.name\" ) protected String mainTopicName ; Bean classes that don\u2019t have a bean defining annotation are not discovered. This behavior is defined by CDI. But producer methods and fields and observer methods are discovered even if the declaring class is not annotated with a bean defining annotation By default, CDI beans are created lazily, when needed. A normal scoped bean (@ApplicationScoped, @RequestScoped, etc.) is needed when a method is invoked upon an injected instance (contextual reference per the specification). A bean with a pseudo-scope (@Dependent and @Singleton ) is created when injected In CDI event Singleton injection may not work as expected due to the propagation of the application context. For example in the case where we need to run the kafka consumer in an executor, we need to pass the configuration to the runner so it get the value injected in the properties, as those value are created in the application context, and will be null in the thread context. The configuration is injected into the runner in the application Bean @ApplicationScoped public class ApplicationBean { @Inject public KafkaConfiguration kafkaConfiguration ; public void onStart ( @Observes StartupEvent ev ) { executorService = Executors . newFixedThreadPool ( 1 ); mainEventRunner = new MainEventsRunner ( kafkaConfiguration ); @ApplicationScoped public class MainEventsRunner implements Runnable {} public KafkaConfiguration kafkaConfiguration ; public MainEventsRunner ( KafkaConfiguration kafkaConfiguration ) { this . kafkaConfiguration = kafkaConfiguration ; }","title":"CDI"},{"location":"quarkus-summary/#quick-list-of-common-commands","text":"See also this Cheat sheer","title":"Quick list of common commands"},{"location":"tests/","text":"Test explanations Tests are using Juni5 and REST assured to validate REST services","title":"Tests"},{"location":"tests/#test-explanations","text":"Tests are using Juni5 and REST assured to validate REST services","title":"Test explanations"}]}