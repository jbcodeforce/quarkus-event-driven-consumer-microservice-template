{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Quarkus Microservice This project uses Quarkus and Kakfa consumer API to deliver a basic structured event driven microservice as a project template. What this project includes: Quarkus project template using: REST easy , SmallRYE open tracing, open API, fault tolerance health, metrics and Kafka client. Using graalVM to run the application. Kafka consumer API examples Nice documentation to present features, design and knowledge sharing using mkdocs See the BOOK view of the documentation. Principles Running the application in dev mode Detail in this note. Tests Detail in this note. Deployment on Openshift CI/CD details","title":"Introduction"},{"location":"#quarkus-microservice","text":"This project uses Quarkus and Kakfa consumer API to deliver a basic structured event driven microservice as a project template. What this project includes: Quarkus project template using: REST easy , SmallRYE open tracing, open API, fault tolerance health, metrics and Kafka client. Using graalVM to run the application. Kafka consumer API examples Nice documentation to present features, design and knowledge sharing using mkdocs See the BOOK view of the documentation.","title":"Quarkus Microservice"},{"location":"#principles","text":"","title":"Principles"},{"location":"#running-the-application-in-dev-mode","text":"Detail in this note.","title":"Running the application in dev mode"},{"location":"#tests","text":"Detail in this note.","title":"Tests"},{"location":"#deployment-on-openshift","text":"CI/CD details","title":"Deployment on Openshift"},{"location":"build-run/","text":"Build and run locally Environment variables used KAFKA_BROKERS KAFKA_APIKEY KAFKA_MAIN_TOPIC TRUSTSTORE_ENABLED TRUSTSTORE_PATH TRUSTSTORE_PWD Running the application in dev mode You can run your application in dev mode that enables live coding using: ./mvnw quarkus:dev When launching a Quarkus app simply using mvn quarkus:dev, the running application is configured to open port 5005 for remote debugging. That means that all you have to do is point your remote debugger to that port and you will be able to debug it in your favorite IDE/lightweight editor. Verify the memory usage: ps -o pid,rss,command -p $(grep -f runner) Packaging and running the application The application is packageable using ./mvnw package . It produces the executable quarkus-kafka-consumer-1.0.0-SNAPSHOT-runner.jar file in /target directory. Be aware that it\u2019s not an \u00fcber-jar as the dependencies are copied into the target/lib directory. The application is now runnable using java -jar target/quarkus-kafka-consumer-1.0.0-SNAPSHOT-runner.jar . Creating and run a native executable Start the GraalVM docker image to work in a contained development environment: docker run -ti -v $( pwd ) :/home -p 8080 :8080 oracle/graalvm-ce:latest You can create a native (to your local OS) executable using: ./mvnw package -Pnative . Or you can use Docker to build the linux native executable using: ./mvnw package -Pnative -Dquarkus.native.container-build = true You can then execute your binary: ./target/quarkus-kafka-consumer-1.0.0-SNAPSHOT-runner","title":"Build & Run"},{"location":"build-run/#build-and-run-locally","text":"","title":"Build and run locally"},{"location":"build-run/#environment-variables-used","text":"KAFKA_BROKERS KAFKA_APIKEY KAFKA_MAIN_TOPIC TRUSTSTORE_ENABLED TRUSTSTORE_PATH TRUSTSTORE_PWD","title":"Environment variables used"},{"location":"build-run/#running-the-application-in-dev-mode","text":"You can run your application in dev mode that enables live coding using: ./mvnw quarkus:dev When launching a Quarkus app simply using mvn quarkus:dev, the running application is configured to open port 5005 for remote debugging. That means that all you have to do is point your remote debugger to that port and you will be able to debug it in your favorite IDE/lightweight editor. Verify the memory usage: ps -o pid,rss,command -p $(grep -f runner)","title":"Running the application in dev mode"},{"location":"build-run/#packaging-and-running-the-application","text":"The application is packageable using ./mvnw package . It produces the executable quarkus-kafka-consumer-1.0.0-SNAPSHOT-runner.jar file in /target directory. Be aware that it\u2019s not an \u00fcber-jar as the dependencies are copied into the target/lib directory. The application is now runnable using java -jar target/quarkus-kafka-consumer-1.0.0-SNAPSHOT-runner.jar .","title":"Packaging and running the application"},{"location":"build-run/#creating-and-run-a-native-executable","text":"Start the GraalVM docker image to work in a contained development environment: docker run -ti -v $( pwd ) :/home -p 8080 :8080 oracle/graalvm-ce:latest You can create a native (to your local OS) executable using: ./mvnw package -Pnative . Or you can use Docker to build the linux native executable using: ./mvnw package -Pnative -Dquarkus.native.container-build = true You can then execute your binary: ./target/quarkus-kafka-consumer-1.0.0-SNAPSHOT-runner","title":"Creating and run a native executable"},{"location":"compendium/","text":"Application Compendium Getting Started with openshift on learn.openshift.com EDA IBM Event Driven Reference architecture Event driven design patterns Kafka producer implementation considerations Kafka consumer implementation considerations Kafka Streams introduction Cloud Native with Quarkus Quarkus guides building native executables REST easy SmallRYE SmallRye develops implementations of Eclipse MicroProfile APIs within any runtime, but here it is for quarkus, and offers a set of components to develop cloud native Java apps. Getting started with Graal VM : GraalVM is a standalone Java Development Kit to execute Java or JVM-based languages (e.g., Scala, Kotlin), dynamic languages (e.g., JavaScript, R, Ruby, R, Python), LLVM-based languages (e.g., C and C++). Java microprofile GraalVM Top 10 Things To Do With GraalVM GraalVM Examples](https://www.graalvm.org/docs/examples/)","title":"Compendium"},{"location":"compendium/#application-compendium","text":"Getting Started with openshift on learn.openshift.com","title":"Application Compendium"},{"location":"compendium/#eda","text":"IBM Event Driven Reference architecture Event driven design patterns Kafka producer implementation considerations Kafka consumer implementation considerations Kafka Streams introduction","title":"EDA"},{"location":"compendium/#cloud-native-with-quarkus","text":"Quarkus guides building native executables REST easy SmallRYE SmallRye develops implementations of Eclipse MicroProfile APIs within any runtime, but here it is for quarkus, and offers a set of components to develop cloud native Java apps. Getting started with Graal VM : GraalVM is a standalone Java Development Kit to execute Java or JVM-based languages (e.g., Scala, Kotlin), dynamic languages (e.g., JavaScript, R, Ruby, R, Python), LLVM-based languages (e.g., C and C++). Java microprofile","title":"Cloud Native with Quarkus"},{"location":"compendium/#graalvm","text":"Top 10 Things To Do With GraalVM GraalVM Examples](https://www.graalvm.org/docs/examples/)","title":"GraalVM"},{"location":"devops/","text":"DevOps Continuous integration Continuous deployment App Monitoring","title":"DevOps"},{"location":"devops/#devops","text":"","title":"DevOps"},{"location":"devops/#continuous-integration","text":"","title":"Continuous integration"},{"location":"devops/#continuous-deployment","text":"","title":"Continuous deployment"},{"location":"devops/#app-monitoring","text":"","title":"App Monitoring"},{"location":"quarkus-summary/","text":"Quarkus Summary Quarkus is a Kubernetes Native Java stack tailored for OpenJDK HotSpot and GraalVM Create a template Using this web site , select the package and download. Using GraalVM Start a container and verify java -version or node . docker run -it -v $( pwd ) :/home oracle/graalvm-ce:20.0.0 bash See other usages here For python: gu install python graalpython GraalVM can compile Java bytecode into native images to achieve faster startup and smaller footprint for your applications. $ javac HelloWorld.java $ native-image HelloWorld $ ./HelloWorld Quick list of common commands See also this Cheat sheer","title":"Quarkus summary"},{"location":"quarkus-summary/#quarkus-summary","text":"Quarkus is a Kubernetes Native Java stack tailored for OpenJDK HotSpot and GraalVM","title":"Quarkus Summary"},{"location":"quarkus-summary/#create-a-template","text":"Using this web site , select the package and download.","title":"Create a template"},{"location":"quarkus-summary/#using-graalvm","text":"Start a container and verify java -version or node . docker run -it -v $( pwd ) :/home oracle/graalvm-ce:20.0.0 bash See other usages here For python: gu install python graalpython GraalVM can compile Java bytecode into native images to achieve faster startup and smaller footprint for your applications. $ javac HelloWorld.java $ native-image HelloWorld $ ./HelloWorld","title":"Using GraalVM"},{"location":"quarkus-summary/#quick-list-of-common-commands","text":"See also this Cheat sheer","title":"Quick list of common commands"},{"location":"tests/","text":"Test explanations","title":"Tests"},{"location":"tests/#test-explanations","text":"","title":"Test explanations"}]}